AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template KVS License Detection Demo'

Parameters:
  LatestAmiId:
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: '/aws/service/canonical/ubuntu/server/22.04/stable/current/amd64/hvm/ebs-gp2/ami-id'
    Description: 'Ubuntu 22.04 LTS AMI from SSM Parameter Store'
  EmailAddress:
    Type: String
    Description: Email address to receive notification when user-data script completes
    AllowedPattern: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$

Resources:
  NotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: EC2UserDataCompletionTopic

  EmailSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Protocol: email
      TopicArn: !Ref NotificationTopic
      Endpoint: !Ref EmailAddress

  EC2KeyPair:
    Type: AWS::EC2::KeyPair
    Properties:
      KeyName: aws-kvs-license-detection-key

  KVSStream:
    Type: AWS::KinesisVideo::Stream
    Properties:
      Name: aws-kvs-license-detection-demo
      DataRetentionInHours: 24
      Tags:
        - Key: Name
          Value: aws-kvs-license-detection-demo

  S3Bucket:
    Type: AWS::S3::Bucket
    DependsOn: LambdaInvokePermission
    Properties:
      BucketName: !Sub aws-kvs-license-detection-s3-${AWS::AccountId}-${AWS::Region}
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      NotificationConfiguration:
        LambdaConfigurations:
          - Event: 's3:ObjectCreated:*'
            Function: !GetAtt LicensePlateDetectionFunction.Arn

  EC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref LatestAmiId
      InstanceType: t3.medium
      KeyName: !Ref EC2KeyPair
      SecurityGroups:
        - !Ref InstanceSecurityGroup
      IamInstanceProfile: !Ref EC2InstanceProfile
      Tags:
        - Key: Name
          Value: aws-kvs-demo
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          set -e  # Exit on error

          # Update package lists and install dependencies in a single command
          DEBIAN_FRONTEND=noninteractive apt-get update && apt-get install -y \
            cmake \
            build-essential \
            pkg-config \
            libssl-dev \
            libcurl4-openssl-dev \
            liblog4cplus-dev \
            libgstreamer1.0-dev \
            libgstreamer-plugins-base1.0-dev \
            gstreamer1.0-plugins-base-apps \
            gstreamer1.0-plugins-bad \
            gstreamer1.0-plugins-good \
            gstreamer1.0-plugins-ugly \
            gstreamer1.0-tools \
            git \
            unzip \
            jq

          # Create working directory and set ownership
          KVS_DIR="/home/ubuntu/amazon-kinesis-video-streams-producer-sdk-cpp"
          mkdir -p $KVS_DIR
          cd /home/ubuntu

          # Clone and build KVS SDK
          git clone https://github.com/awslabs/amazon-kinesis-video-streams-producer-sdk-cpp.git
          cd $KVS_DIR
          mkdir -p build && cd build
          cmake .. -DBUILD_GSTREAMER_PLUGIN=ON -DBUILD_DEPENDENCIES=OFF -DALIGNED_MEMORY_MODEL=ON
          make -j$(nproc)

          # Set up environment
          echo "export GST_PLUGIN_PATH=$KVS_DIR/build" >> /home/ubuntu/.bashrc
          export GST_PLUGIN_PATH=$KVS_DIR/build

          # Install AWS CLI v2
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          ./aws/install
          rm -rf aws awscliv2.zip

          # Create update-image-generation-input.json
          cat > /home/ubuntu/update-image-generation-input.json << EOF
          {
            "StreamName": "aws-kvs-license-detection-demo",
            "ImageGenerationConfiguration": {
              "Status": "ENABLED",
              "DestinationConfig": {
                "DestinationRegion": "${AWS::Region}",
                "Uri": "s3://aws-kvs-license-detection-s3-${AWS::AccountId}-${AWS::Region}"
              },
              "SamplingInterval": 5000,
              "ImageSelectorType": "SERVER_TIMESTAMP",
              "Format": "JPEG",
              "FormatConfig": {
                "JPEGQuality": "80"
              },
              "WidthPixels": 1280,
              "HeightPixels": 720
            }
          }
          EOF

          # Update KVS image generation configuration
          aws kinesisvideo update-image-generation-configuration \
            --cli-input-json file:///home/ubuntu/update-image-generation-input.json

          # Set up video streaming
          VIDEO_DIR="/home/ubuntu/videos"
          mkdir -p $VIDEO_DIR
          cd $VIDEO_DIR
          wget -q https://github.com/intel-iot-devkit/sample-videos/raw/refs/heads/master/car-detection.mp4

          # Create streaming script
          cat > /home/ubuntu/stream-video.sh << 'EOF'
          #!/bin/bash
          set -e
          export GST_PLUGIN_PATH=/home/ubuntu/amazon-kinesis-video-streams-producer-sdk-cpp/build

          # Get credentials with error handling
          ROLE_NAME=$(curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/)
          CREDENTIALS=$(curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME)
          export AWS_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.AccessKeyId')
          export AWS_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.SecretAccessKey')
          export AWS_SESSION_TOKEN=$(echo $CREDENTIALS | jq -r '.Token')
          export AWS_DEFAULT_REGION=${AWS::Region}

          if [ -z "$AWS_ACCESS_KEY_ID" ] || [ -z "$AWS_SECRET_ACCESS_KEY" ]; then
            echo "Failed to retrieve credentials"
            exit 1
          fi
          
          cd ~/amazon-kinesis-video-streams-producer-sdk-cpp/build
          ./kvs_gstreamer_sample aws-kvs-license-detection-demo ~/videos/car-detection.mp4
          EOF

          # Set correct ownership and permissions
          chown ubuntu:ubuntu /home/ubuntu/stream-video.sh
          chmod +x /home/ubuntu/stream-video.sh

          # Set correct ownership for all files in ubuntu's home directory
          chown -R ubuntu:ubuntu /home/ubuntu/
          
          # Make videos directory and set permissions
          mkdir -p /home/ubuntu/videos
          chown -R ubuntu:ubuntu /home/ubuntu/videos
          chmod 755 /home/ubuntu/videos

          # Get instance ID and create connect URL
          INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)
          CONNECT_URL="https://${AWS::AccountId}.console.aws.amazon.com/ec2/home?region=${AWS::Region}#ConnectToInstance:instanceId=$INSTANCE_ID"

          # Create a more detailed message
          MESSAGE=$(cat <<EOF
          EC2 instance $INSTANCE_ID has completed user-data script initialization.

          Instance Details:
          - Instance ID: $INSTANCE_ID
          - Region: ${AWS::Region}
          - Account ID: ${AWS::AccountId}

          Connect to your instance using:
          $CONNECT_URL

          Note: Make sure you're logged into the AWS Console before using this URL.
          EOF
          )

          # Send completion notification with the connect URL
          aws sns publish \
            --topic-arn ${NotificationTopic} \
            --message "$MESSAGE" \
            --subject "EC2 UserData Script Complete - Instance $INSTANCE_ID" \
            --region ${AWS::Region}

          # Log completion
          echo "UserData script completed successfully and notification sent with connect URL"

  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonKinesisVideoStreamsFullAccess
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
      Policies:
        - PolicyName: SNSPublishPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: sns:Publish
                Resource: !Ref NotificationTopic

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref EC2Role

  InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable SSH access via port 22
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
        - arn:aws:iam::aws:policy/AmazonRekognitionFullAccess
        - arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  LicensePlateDetectionFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: LicensePlateDetectionFunction
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.9
      Timeout: 60
      MemorySize: 256
      Code:
        ZipFile: |
          import json
          import urllib.parse
          import boto3
          import logging
          import time
          import re
          from decimal import Decimal 
          from botocore.exceptions import ClientError

          print('Loading function')

          s3 = boto3.client('s3')
          rekognition_client = boto3.client('rekognition')
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          class RekognitionLabel:
              def __init__(self, label, timestamp=None):
                  self.name = label.get("Name")
                  self.confidence = label.get("Confidence")
                  self.instances = label.get("Instances")
                  self.parents = label.get("Parents")
                  self.timestamp = timestamp

              def to_dict(self):
                  rendering = {}
                  if self.name is not None:
                      rendering["name"] = self.name
                  if self.timestamp is not None:
                      rendering["timestamp"] = self.timestamp
                  return rendering

          class RekognitionImage:
              def __init__(self, image, image_name, rekognition_client):
                  self.image = image
                  self.image_name = image_name
                  self.rekognition_client = rekognition_client

              @classmethod
              def from_bucket(cls, s3_object, rekognition_client):
                  image = {"S3Object": {"Bucket": s3_object.bucket_name, "Name": s3_object.key}}
                  return cls(image, s3_object.key, rekognition_client)

              def detect_labels(self, max_labels):
                  try:
                      response = self.rekognition_client.detect_labels(
                          Image=self.image, MaxLabels=max_labels
                      )
                      labels = response['Labels']
                      print(f'Found {len(labels)} labels in the image:')
                      label_names = ''
                      for label in labels:
                          name = label['Name']
                          confidence = label['Confidence']
                          if confidence > 95:
                              print(name + "|" + str(confidence))
                              label_names = label_names + name + ","
                      
                  except ClientError:
                      logger.info("Couldn't detect labels in %s.", self.image_name)
                      raise
                  else:
                      return labels
              
              def detect_text(self):
                  try:
                      response = self.rekognition_client.detect_text(Image=self.image)
                      text_detections = response['TextDetections']
                      print(f'Found {len(text_detections)} text instances in the image')
                      return text_detections
                  except ClientError:
                      logger.error("Couldn't detect text in %s.", self.image_name)
                      raise
              
              def extract_license_plate(self):
                  # First detect all text in the image
                  text_detections = self.detect_text()
                  
                  # Look for license plates among detected labels
                  labels = self.detect_labels(100)
                  has_license_plate = False
                  
                  for label in labels:
                      if label['Name'].lower() in ['license plate', 'vehicle registration plate']:
                          has_license_plate = True
                          break
                  
                  # Extract potential license plate text
                  license_plate_text = None
                  highest_confidence = 0
                  
                  # If we found a license plate, look for text that might be the plate number
                  if has_license_plate:
                      for text in text_detections:
                          detected_text = text['DetectedText']
                          confidence = text['Confidence']
                          
                          # Check if text length is between 6 and 8 characters
                          if (text['Type'] == 'WORD' and 
                              6 <= len(detected_text) <= 8 and
                              # Check if text contains both letters and numbers
                              any(c.isalpha() for c in detected_text) and 
                              any(c.isdigit() for c in detected_text) and
                              # Check if confidence is greater than 90
                              confidence > 90 and
                              confidence > highest_confidence):
                              
                              license_plate_text = detected_text
                              highest_confidence = confidence
                              print(f"Found potential license plate: {detected_text} with confidence {confidence}")
                              print(text)
                              print(license_plate_text)
                  
                  return {
                      'image_name': self.image_name,
                      'license_plate_text': license_plate_text,
                      'confidence': Decimal(str(highest_confidence)) if highest_confidence else Decimal('0'),
                      'has_license_plate': has_license_plate
                  }

          def ensure_table_exists(dynamodb_client, table_name):
              try:
                  dynamodb_client.describe_table(TableName=table_name)
                  logger.info(f"Table {table_name} already exists")
              except dynamodb_client.exceptions.ResourceNotFoundException:
                  logger.info(f"Creating table {table_name}")
                  dynamodb_client.create_table(
                      TableName=table_name,
                      KeySchema=[
                          {'AttributeName': 'image_name', 'KeyType': 'HASH'},  # Partition key
                      ],
                      AttributeDefinitions=[
                          {'AttributeName': 'image_name', 'AttributeType': 'S'},
                      ],
                      ProvisionedThroughput={'ReadCapacityUnits': 5, 'WriteCapacityUnits': 5}
                  )
                  # Wait for table creation
                  dynamodb_client.get_waiter('table_exists').wait(TableName=table_name)
                  logger.info(f"Table {table_name} created successfully")

          def convert_floats_to_decimals(obj):
              """Convert all float values in a dictionary to Decimal objects for DynamoDB compatibility"""
              if isinstance(obj, dict):
                  return {k: convert_floats_to_decimals(v) for k, v in obj.items()}
              elif isinstance(obj, list):
                  return [convert_floats_to_decimals(i) for i in obj]
              elif isinstance(obj, float):
                  return Decimal(str(obj))
              else:
                  return obj

          class DecimalEncoder(json.JSONEncoder):
              def default(self, obj):
                  if isinstance(obj, Decimal):
                      return float(obj)
                  return super(DecimalEncoder, self).default(obj)

          def lambda_handler(event, context):
              # Initialize DynamoDB client
              dynamodb = boto3.resource('dynamodb')
              dynamodb_client = boto3.client('dynamodb')
              table_name = 'LicensePlateDetections'
              
              # Ensure the table exists
              ensure_table_exists(dynamodb_client, table_name)
              table = dynamodb.Table(table_name)
              
              # Get the object from the event
              bucket_name = event['Records'][0]['s3']['bucket']['name']
              image_name = urllib.parse.unquote_plus(event['Records'][0]['s3']['object']['key'], encoding='utf-8')
              
              # Process the image
              s3_object = boto3.resource("s3").Object(bucket_name, image_name)
              rekognition_image = RekognitionImage.from_bucket(s3_object, rekognition_client)
              
              # Extract license plate information
              license_plate_info = rekognition_image.extract_license_plate()
              
              # Add timestamp
              license_plate_info['timestamp'] = int(time.time())
              
              # Store in DynamoDB if a license plate was detected with confidence > 90
              if license_plate_info['license_plate_text'] and license_plate_info['confidence'] > 90:
                  try:
                      # Already converted confidence to Decimal in extract_license_plate
                      table.put_item(Item=license_plate_info)
                      logger.info(f"Successfully stored license plate data for {image_name}")
                  except Exception as e:
                      logger.error(f"Error storing data in DynamoDB: {str(e)}")
              else:
                  logger.info(f"No license plate detected with sufficient confidence in {image_name}")
              
              return {
                  'headers': {"Content-Type": "image/png"},
                  'statusCode': 200,
                  'body': json.dumps({
                      'message': 'Image processed successfully',
                      'license_plate_detected': license_plate_info['license_plate_text'] is not None and license_plate_info['confidence'] > 90,
                      'license_plate': license_plate_info.get('license_plate_text', 'None detected'),
                      'confidence': float(license_plate_info['confidence']) if license_plate_info['confidence'] else 0
                  }, cls=DecimalEncoder),
                  'isBase64Encoded': False
              }

  LicensePlateDetectionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: LicensePlateDetections
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: image_name
          AttributeType: S
      KeySchema:
        - AttributeName: image_name
          KeyType: HASH

  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref LicensePlateDetectionFunction
      Principal: s3.amazonaws.com
      SourceAccount: !Ref AWS::AccountId
      SourceArn: !Sub arn:aws:s3:::aws-kvs-license-detection-s3-${AWS::AccountId}-${AWS::Region}

Outputs:
  InstanceId:
    Description: Instance ID of the created EC2 instance
    Value: !Ref EC2Instance
  PublicDNS:
    Description: Public DNS name of the created EC2 instance
    Value: !GetAtt EC2Instance.PublicDnsName
  PublicIP:
    Description: Public IP address of the created EC2 instance
    Value: !GetAtt EC2Instance.PublicIp
  KeyPairName:
    Description: Name of the created key pair
    Value: !Ref EC2KeyPair
  KVSStreamName:
    Description: Name of the created KVS stream
    Value: !Ref KVSStream
  S3BucketName:
    Description: Name of the created S3 bucket
    Value: !Ref S3Bucket
  LambdaFunctionName:
    Description: Name of the Lambda function for license plate detection
    Value: !Ref LicensePlateDetectionFunction
  DynamoDBTableName:
    Description: Name of the DynamoDB table for license plate detections
    Value: !Ref LicensePlateDetectionsTable
  SNSTopicARN:
    Description: ARN of the SNS Topic for notifications
    Value: !Ref NotificationTopic
